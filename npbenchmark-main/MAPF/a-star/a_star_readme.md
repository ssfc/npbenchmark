https://www.geeksforgeeks.org/a-search-algorithm/

closed_list每轮循环进入1个元素，open_list可能每轮循环进入多个元素，排出1个元素。在找到出口时，open_list可能不为空。(2023年7月26日)

### Q: A*算法求的是精确解还是次优解？

A*算法通常被设计用于在图或网络中找到最短路径（或最优解）。它是一种启发式搜索算法，综合了广度优先搜索和启发式函数的优势，以寻找具有最小总代价的路径。

在搜索过程中，A\*算法会根据节点的估计代价（启发式函数的值）来指导搜索方向，优先选择估计代价最小的节点进行扩展。这使得A*算法倾向于先探索可能更接近目标的路径，从而更有可能找到最短路径或最优解。

当A*算法满足以下两个条件时，它可以找到精确解：
1. A*算法使用的启发式函数是一致的（consistent），也称为满足三角不等式。这意味着从一个节点到其后继节点的实际代价不大于启发式函数估计的代价。
2. 图中没有负权边（即所有边的权重都非负）。

在这种情况下，A*算法保证找到的解是最短路径，也就是精确解。

然而，如果上述条件不满足，A\*算法可能找到的是次优解。在存在负权边或不满足一致性的情况下，A*算法无法保证找到最短路径，可能会在搜索过程中偏向某些路径，导致找到的解不是全局最优解。

因此，A\*算法在满足条件时可以找到精确解，但在某些情况下可能找到次优解。为了确保A*算法找到全局最优解，需要满足一致性条件并避免负权边。同时，合理选择启发式函数也对算法的性能和结果有重要影响。

### Q: 启发式函数是一致的（consistent）是什么意思？

启发式函数是一致的（consistent）是指启发式函数在满足以下条件时称为一致函数：

对于图中的每个节点N和N的每个邻居节点N'，如果从节点N移动到节点N'的实际代价是c(N, N')，而启发式函数的估计值为h(N)和h(N')，那么启发式函数h(x)必须满足以下条件：

h_score(N) <= c(N, N') + h_score(N')

换句话说，对于任意节点N和它的每个邻居节点N'，启发式函数估计从N到N'的最短路径的代价不会大于实际的路径代价。这个条件也被称为满足三角不等式。

在A\*算法中，如果使用的启发式函数是一致的，那么A\*算法将能够保证找到最短路径，也就是找到全局最优解。一致的启发式函数确保A*算法在搜索过程中以最优的方式进行节点扩展，优先探索可能更接近目标的路径，从而有效地找到最短路径。

### Q: A*算法是完备的吗？

A\*算法在某些条件下是完备的，但并不是在所有情况下都能保证找到解。A*算法的完备性与问题的特性以及启发式函数的选择有关。

A\*算法在搜索过程中使用启发式函数来引导搜索，它通过估计从当前节点到目标节点的代价，帮助算法朝着最优路径的方向前进。如果启发式函数满足以下两个条件，那么A*算法是完备的：

1. 可行性条件（Admissibility）：启发式函数对于所有节点都是一个合理的估计，且不会高估到达目标节点的代价。换句话说，启发式函数应该满足 h_score(n) <= h_score\*(n)，其中 h_score(n) 表示启发式函数估计的从节点 n 到目标节点的代价，h_score*(n) 表示节点 n 到目标节点的实际最小代价。

2. 一致性条件（Consistency，或者称为单调性）：启发式函数应该满足对于任意节点 n 的**所有后继**节点 n'，有 h_score(n) <= c(n, n') + h_score(n')，其中 c(n, n') 表示从节点 n 到后继节点 n' 的实际代价。换句话说，启发式函数估计的代价不会“反悔”，它满足三角不等式。

如果启发式函数同时满足可行性和一致性条件，那么A\*算法是完备的，即在有限状态空间中，它能够找到从起始节点到目标节点的最优路径。然而，要注意的是，A\*算法的完备性并不保证在所有问题和状态空间中都能找到解，特别是当状态空间非常大或者存在特殊的障碍物配置时，A*算法可能会遇到搜索空间过大的情况，导致搜索不到解或者计算代价非常高。

在实际应用中，选择合适的启发式函数对于A*算法的性能至关重要。一个好的启发式函数能够在保证完备性的前提下，提高算法的搜索效率，使其更快地找到最优路径。

### Q: 如果要学习一个新算法，应该用怎样的步骤、从哪些方面去把握它？

学习一个新算法可以通过以下步骤和方面来把握：

1. **了解算法的基本思想**：
   - 首先，了解算法解决的问题是什么，以及它的基本思想是怎样的。弄清楚算法的输入和输出是什么，它是如何运作的，以及解决问题的关键步骤。

2. **学习算法的原理和证明**：
   - 了解算法的详细原理和推导过程，掌握其正确性和复杂度分析。理解算法的时间复杂度和空间复杂度，以及为什么算法有效。

3. **查找经典实现和代码示例**：
   - 在学习算法时，查找并阅读经典的算法实现和代码示例是非常有帮助的。可以参考教科书、学术论文、博客文章或开源项目中的代码实现。

4. **动手实现算法**：
   - 亲自动手实现算法是学习的关键步骤。通过自己编写代码来理解算法的细节，并且从中获得更深入的认识。在实现过程中，可以进行调试和测试，确保算法正确运行。

5. **尝试不同的输入和边界条件**：
   - 将算法应用于不同的输入数据和边界条件，观察算法的行为和输出结果。这有助于深入理解算法的工作原理和特点。

6. **理解算法的应用场景**：
   - 理解算法在实际问题中的应用场景和适用性。了解它在现实生活或工程中的应用，帮助理解算法的实际价值。

7. **比较算法和优化**：
   - 学习不同算法之间的区别和优缺点。了解在特定情况下，哪种算法更适合解决问题，并思考如何优化算法以满足特定需求。

8. **阅读相关文献和资料**：
   - 深入学习算法的话题，可以查阅相关的学术论文、书籍、博客文章或教程。有时候，多个资源的结合能够更好地理解和掌握算法。

9. **参与实际项目和练习**：
   - 在实际项目中应用算法或者参与练习，将学到的知识应用到实际场景中，加深对算法的理解和熟练度。

10. **与他人交流和讨论**：
    - 与他人交流和讨论学习的算法，参与算法相关的社区或讨论组，分享学习心得和解决问题。

总之，学习新算法需要耐心和坚持，通过理论学习、实践编码和应用实践相结合的方式，逐步掌握算法的原理和应用。不同算法的学习难度和深度会有所不同，因此根据自己的学习能力和目标，合理安排学习计划和步骤。

### Q: 请展开论述第一点：了解算法的基本思想

了解算法的基本思想是学习新算法的第一步，它为学习后续的细节奠定了基础。下面展开论述这一点：

1. **问题背景和描述**：
   - 在了解一个新算法之前，首先需要了解该算法是用来解决什么问题的。问题的背景和描述对于理解算法的应用场景和意义至关重要。搞清楚问题的输入、输出以及期望的解决结果是什么，可以帮助理解算法的实际用途。

2. **基本思想概述**：
   - 掌握算法的基本思想，包括其解决问题的一般方法和策略。算法的基本思想是算法设计的核心，它可以是一种常见的模式、策略或步骤，用于解决特定类型的问题。

3. **算法流程图或伪代码**：
   - 查阅相关资料，寻找算法的流程图或伪代码，从宏观上了解算法的工作流程。流程图或伪代码可以帮助抓住算法的主要步骤和逻辑结构，便于后续细节的学习。

4. **举例理解**：
   - 通过实际的例子来说明算法的基本思想。选取一些简单的输入样例，手动模拟算法的执行过程，从而更好地理解算法是如何运作的。

5. **和其他算法的区别**：
   - 比较该算法与其他解决相同问题的算法之间的区别。了解该算法相较于其他算法的优势和局限性，帮助选择合适的算法来解决具体问题。

6. **解决的问题类型**：
   - 了解算法适用的问题类型和条件。有些算法可能只适用于特定类型的问题，了解其应用范围有助于确定何时使用该算法。

7. **学习资料和资源**：
   - 查找与该算法相关的学习资料和资源，包括教科书、学术论文、博客文章或教程。阅读多个来源的解释，有助于加深对基本思想的理解。

了解算法的基本思想为学习后续的原理、代码实现以及应用提供了框架。只有理解了算法的核心思想，才能在学习过程中更加深入和有针对性地学习算法的细节。

### Q: 为什么这样建议？Clang-Tidy: Use emplace instead of push 

这个建议是由 Clang-Tidy 给出的，它是 Clang C++ 编译器的一个静态代码分析工具。该建议是在代码中使用 `emplace` 替代 `push` 的提示。

在 C++ 中，`push` 是用于向容器（如 vector、list、set 等）添加元素的方法，而 `emplace` 则是 C++11 引入的方法，用于在容器中直接构造元素，而不是先创建一个临时对象再拷贝或移动到容器。

使用 `emplace` 可以避免不必要的对象拷贝或移动操作，提高代码的性能。因此，Clang-Tidy 给出这个建议是为了鼓励程序员使用 `emplace` 来代替 `push`，以获得更好的性能和效率。

举个例子，对于 `std::vector<int>` 容器，`push` 用于将一个整数添加到容器末尾：

```cpp
std::vector<int> myVector;
myVector.push_back(42);
```

而使用 `emplace` 可以直接在容器中构造整数：

```cpp
std::vector<int> myVector;
myVector.emplace_back(42);
```

使用 `emplace` 而不是 `push` 可以避免创建临时整数对象，并直接在容器中构造元素，提高了性能和效率。但需要注意，`emplace` 在构造复杂对象时需要提供构造参数，因此使用时需根据具体情况选择合适的方法。

### Q: A*算法一般用于二维网格图吗？

A*算法并不限于二维网格图，但它最常用于解决在二维网格或图上的路径搜索问题。

A*算法是一种启发式搜索算法，用于在图或网格上寻找从起点到目标点的最短路径。它在图中进行搜索，通过评估每个节点的估计成本（启发式函数）来指导搜索方向，从而更快地找到最优路径。

虽然A\*算法最常用于解决二维网格或图上的路径搜索问题，但它理论上可以应用于更复杂的拓扑结构。只要能够定义合适的启发式函数和状态转移规则，A*算法就可以在不同类型的图或网络中使用。

在实际应用中，A\*算法通常用于解决地图导航、游戏AI、机器人路径规划等问题，这些场景下常见的是二维网格地图。但如果问题涉及到其他形式的图或网络，也可以尝试将A*算法进行适当的调整和应用。

### Q: typedef pair<int, int> Pair中的typedef可以省略吗？

是的，`typedef` 可以省略，可以使用 C++11 引入的更现代的方式来定义类型别名。C++11 引入了 `using` 关键字，可以更简洁地定义类型别名，其语法如下：

```cpp
using Pair = std::pair<int, int>;
```

这样就可以将 `std::pair<int, int>` 定义为 `Pair` 类型的别名，使得代码更加清晰和易读。`using` 语法在类型别名的定义上比 `typedef` 更直观和符合现代 C++ 编程风格，因此在新的 C++ 代码中，更推荐使用 `using` 来定义类型别名。

但是，如果你的代码要兼容较旧的 C++ 版本，或者在一些特定的代码库或项目中，仍然会看到 `typedef` 的使用。在这些情况下，`typedef` 是有效且合法的，只是在新的代码中，更多地使用 `using` 是更为常见的做法。

### Q: 用中文解读A*伪代码（from wikipedia）： 

```
function reconstruct_path(cameFrom, current)
    total_path := {current}
    while current in cameFrom.Keys:
        current := cameFrom[current]
        total_path.prepend(current)
    return total_path

// A* finds a path from start to goal.
// h_score is the heuristic function. h_score(n) estimates the cost to reach goal from node n.
function A_Star(start, goal, h_score)
    // The set of discovered nodes that may need to be (re-)expanded.
    // Initially, only the start node is known.
    // This is usually implemented as a min-heap or priority queue rather than a hash-set.
    openSet := {start}

    // For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from the start
    // to n currently known.
    cameFrom := an empty map

    // For node n, gScore[n] is the cost of the cheapest path from start to n currently known.
    gScore := map with default value of Infinity
    gScore[start] := 0

    // For node n, fScore[n] := gScore[n] + h_score(n). fScore[n] represents our current best guess as to
    // how cheap a path could be from start to finish if it goes through n.
    fScore := map with default value of Infinity
    fScore[start] := h_score(start)

    while openSet is not empty
        // This operation can occur in O(Log(N)) time if openSet is a min-heap or a priority queue
        current := the node in openSet having the lowest fScore[] value
        if current = goal
            return reconstruct_path(cameFrom, current)

        openSet.Remove(current)
        for each neighbor of current
            // d(current,neighbor) is the weight of the edge from current to neighbor
            // tentative_gScore is the distance from start to the neighbor through current
            tentative_gScore := gScore[current] + d(current, neighbor)
            if tentative_gScore < gScore[neighbor]
                // This path to neighbor is better than any previous one. Record it!
                cameFrom[neighbor] := current
                gScore[neighbor] := tentative_gScore
                fScore[neighbor] := tentative_gScore + h_score(neighbor)
                if neighbor not in openSet
                    openSet.add(neighbor)

    // Open set is empty but goal was never reached
    return failure
```

这段伪代码描述了 A*（A星）搜索算法的执行过程，该算法用于在图或网络中搜索从起点到目标点的最短路径。下面对每一步进行解读：

1. 初始化开放列表（open list）：开放列表用于存储待扩展的节点，初始时为空。

2. 初始化封闭列表（closed list）：封闭列表用于存储已经扩展过的节点，初始时为空。将起始节点放入开放列表，可以将其 f_score 值设为0（这里 f_score 表示估计的总路径代价）。

3. 当开放列表不为空时，执行以下步骤：
   a) 在开放列表中找到 f_score 值最小的节点，将其称为 "q"。(最开始就是起点了)
   b) 将 "q" 从开放列表中移除。
   c) 生成 "q" 的8个后继节点，并将它们的父节点设置为 "q"。(设置父节点是为了储存路径方便回溯)
   d) 对于每个后继节点：
      i) 如果后继节点是目标节点，则停止搜索，找到了最短路径。
      ii) 否则，计算后继节点的 g_score 和 h_score 值：
          - g_score 值表示从起点到当前节点的实际代价（即实际路径长度）。
                 - h_score 值表示当前节点到目标节点的估计代价（即启发式函数估计的路径长度）。
                 这一步中，可以使用三种启发式函数来计算 h_score 值：曼哈顿距离、对角线距离和欧几里得距离。
                 successor.g_score = q.g_score + 从 "q" 到后继节点的距离
                 successor.h_score = 从后继节点到目标节点的距离（可以通过多种方式计算，如曼哈顿距离、对角线距离或欧几里得距离）。
                 successor.f_score = successor.g_score + successor.h_score
         iii) 如果与后继节点位置相同的节点在开放列表中具有更小的 f_score 值，则跳过该后继节点。
         iV) 如果与后继节点位置相同的节点在封闭列表中具有更小的 f_score 值，则跳过该后继节点，否则将该节点添加到开放列表。
   e) 将 "q" 添加到封闭列表。

整个过程在一个 while 循环中进行，直到找到目标节点或开放列表为空为止。A*算法通过选择 f_score 值最小的节点来扩展，同时使用启发式函数的估计值来引导搜索方向，从而更快地找到最优路径。

### Q: 这个伪代码对A*的表述是否准确？

对A\*算法的基本思想和流程，这个伪代码的表述是准确的。它描述了A\*搜索算法的主要步骤，包括初始化开放列表和封闭列表、循环扩展节点、计算节点的代价和启发式函数、更新开放列表和封闭列表等。A*算法的关键在于维护一个估价函数（启发式函数），它能够引导搜索过程朝着最有希望的方向前进，以减少搜索的时间和空间复杂度。

不过，可能有一些细节上的不足或未提及的情况，比如对于重复节点的处理，以及估价函数的选择等。在具体实现A*算法时，还需要考虑这些细节，并确保代码的正确性和高效性。此外，这里提到了三种启发式函数（曼哈顿距离、对角线距离和欧几里得距离），但具体使用哪种启发式函数还需要根据具体问题和应用场景来选择。

总的来说，这个伪代码对A\*算法的基本流程和思想进行了正确的表述，但在实际应用中，可能需要根据具体问题做一些调整和优化。在编写实际的A\*算法实现时，还需仔细考虑细节，并对具体问题进行适当的调整和优化。

### Q: 为什么”iii) 如果与后继节点位置相同的节点在开放列表中具有更小的 f_score 值，则跳过该后继节点。“？目的是什么？

这里的目的是为了确保在A*算法的搜索过程中，不重复扩展已经在开放列表中的节点，避免浪费不必要的计算和搜索代价。

在A*算法中，每个节点都有一个 f_score 值，表示该节点的综合评估代价。为了找到最优路径，我们需要尽量选择 f_score 值较小的节点进行扩展。当我们生成一个节点的后继节点时，可能会得到一些与已经在开放列表中的节点位置相同的节点。如果这些后继节点在开放列表中已经有了，我们可以比较它们的 f_score 值，如果后继节点的 f_score 值较小，说明通过其他路径到达该节点的代价更低，因此我们可以跳过这些后继节点，不再重复扩展它们。

这个操作称为 "跳过重复节点"，是A*算法的一个重要优化措施。通过这个优化，可以减少重复计算和搜索，加快算法的执行速度，提高算法的效率。

总结来说，"跳过重复节点" 的目的是为了优化A*算法的搜索过程，避免重复扩展已经在开放列表中的节点，以提高搜索效率，寻找更快的最优路径。

### Q: A*算法的搜索过程直观上看是像一道光束一样向目标延拓吗？

在直观上，可以将A\*算法的搜索过程比喻为一道光束朝着目标延伸。A*算法利用启发式函数（heuristic function）来引导搜索方向，使得搜索过程更加高效，类似于一道光束朝着目标前进。

启发式函数用于估计从当前节点到目标节点的代价，它提供了关于节点距离目标节点的信息。A\*算法在搜索过程中通过综合考虑节点的实际代价（g值，即从起点到当前节点的实际路径代价）和启发式函数的估计代价（h值，即当前节点到目标节点的估计路径代价），计算出节点的总代价（f值，f_score = g_score + h_score）。在选择下一个要扩展的节点时，A*算法倾向于选择具有较小f值的节点，这使得搜索过程更有可能朝着目标节点的方向前进。

类比为光束，可以将启发式函数看作是“引导光束”，通过引导光束的方向，搜索过程更有可能朝着目标节点的方向延伸。这种引导作用使得A*算法在搜索过程中更加聚焦于可能较优的路径，从而避免扩展过多不必要的节点，提高搜索效率，找到较快的最优路径。

尽管这种类比是直观的，但需要注意的是，A\*算法的搜索过程实际上是一个离散的过程，通过逐步扩展节点来搜索路径。它并不是真正的“连续光束”，而是通过计算和选择合适的节点来进行搜索。不过这个比喻可以帮助理解A*算法的思想和搜索策略。

### Q: 之所以将 "q" 的8个后继节点的父节点设置为 "q"，是为了储存路径吗？

是的，设置 "q" 的8个后继节点的父节点为 "q" 是为了在找到目标节点后能够回溯并重构最优路径。通过设置父节点，可以在找到目标节点后，沿着每个节点的父节点一直回溯到起始节点，从而得到从起始节点到目标节点的最短路径。

当A*算法找到目标节点时，封闭列表中存储了从起始节点到目标节点的所有节点，以及它们的父节点信息。通过这些父节点信息，可以从目标节点开始，逐步回溯到起始节点，重构出一条最短路径。

具体地说，假设目标节点为 "goal"，在找到 "goal" 后，可以通过以下步骤重构最短路径：
1. 从 "goal" 开始，沿着其父节点一直向上回溯，直到到达起始节点，将每个节点依次添加到一个路径容器中，即得到从起始节点到目标节点的最短路径。

通过设置父节点，A*算法可以高效地在搜索过程中保存节点之间的关系，从而在找到目标节点后，快速地重构出最优路径。这也是A*算法高效求解最短路径的一个重要原因。

### Q: 如果与后继节点位置相同的节点在开放列表中具有更小的 f_score 值"中的位置相同是什么意思？

在这里，“位置相同”的意思是指后继节点和已经在开放列表中的节点处于相同的位置或坐标。A*算法是在图或网格结构中进行搜索，每个节点都有一组坐标来表示其位置。

当生成一个节点的后继节点时，这些后继节点可能会与已经在开放列表中的节点具有相同的位置（即坐标）。这种情况可能发生在图或网格中存在多条路径经过同一个位置时。

在A*算法中，如果一个后继节点和已经在开放列表中的节点处于相同的位置，并且后继节点的f值更小，那么**说明通过当前路径到达该后继节点的代价更小**，这时我们可以跳过该后继节点，不再重复扩展它，因为已经存在一个更优的路径到达了这个位置。

通过这种处理，A*算法能够避免在搜索过程中重复扩展相同位置的节点，从而减少了搜索空间，提高了搜索效率，更快地找到最优路径。

### Q: 怎样生成后继结点？

生成后继节点是A\*算法中一个重要的步骤，它是通过对当前节点进行操作（比如移动一步）来产生新的节点，这些新节点位于当前节点的周围，被称为后继节点。在A*算法中，后继节点的生成方式取决于问题的具体特点和状态空间的定义。

在典型的二维网格地图中，以当前节点为中心，可以向上、下、左、右四个方向扩展，每次扩展一个格子。如果允许斜向移动，还可以在四个主方向上加上对角线方向（共八个方向）。

以一个简单的示例来说明生成后继节点的过程，假设当前节点为 `(x, y)`，下面是生成后继节点的伪代码：

```cpp
// 生成后继节点
vector<Node> generateSuccessors(Node currentNode) {
    vector<Node> successors;
    int x = currentNode.x;
    int y = currentNode.y;

    // 向上扩展
    if (isValid(x, y - 1)) {
        successors.push_back(Node(x, y - 1));
    }

    // 向下扩展
    if (isValid(x, y + 1)) {
        successors.push_back(Node(x, y + 1));
    }

    // 向左扩展
    if (isValid(x - 1, y)) {
        successors.push_back(Node(x - 1, y));
    }

    // 向右扩展
    if (isValid(x + 1, y)) {
        successors.push_back(Node(x + 1, y));
    }

    // 如果允许对角线移动，还可以添加对角线方向的扩展

    return successors;
}
```

在上述示例中，`Node` 表示网格地图中的节点，`x` 和 `y` 是节点的坐标。`isValid(x, y)` 是一个辅助函数，用于检查节点 `(x, y)` 是否是一个合法的节点（即是否在地图范围内，并且不是障碍物）。

具体生成后继节点的方式取决于问题的情况，可以根据具体问题和状态空间的定义来设计合适的后继节点生成方法。

### Q: 在A*算法结束，close list里面包含哪些元素？

在A\*算法结束时，closed list（关闭列表）中包含已经被完全探索过的节点，也就是说这些节点已经被算法评估过，找到了从起始节点到该节点的最优路径。下面列出了A*算法结束时closed list中可能包含的元素：

1. 起始节点（起点）：起始节点是算法开始的地方，所以在结束时，起始节点一定会被包含在closed list中。

2. 目标节点（终点）：如果终点能够被访问到，即从起点存在一条路径到达终点，那么在A*算法结束时，终点也会被包含在closed list中。

3. 中间节点：在A*算法的执行过程中，除了起点和终点，还会探索和评估其他中间节点。这些中间节点可能在结束时包含在closed list中。

总结：A*算法结束时，closed list会包含起始节点、终点（如果可达），以及所有被完全探索过的中间节点。这些节点都已经被算法遍历和评估过，形成了最优路径。
