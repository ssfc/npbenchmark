# Fast heuristics for the multiple traveling thieves problem

(Prompt: 翻译本文标题)

多旅行窃贼问题的快速启发式算法

https://github.com/ssfc/npbenchmark/blob/main/npbenchmark-main/travel_thief/2016%20Fast%20heuristics%20for%20the%20multiple%20traveling%20thieves%20problem.pdf

https://github.com/ssfc/npbenchmark/blob/main/npbenchmark-main/travel_thief/2016%20Fast%20heuristics%20for%20the%20multiple%20traveling%20thieves%20problem.md

## Abstract

(Prompt: generalize abstract of this article in Chinese)

本文讨论了旅行窃贼问题的现有形式的不足之处，并提出了一个放宽的问题版本，允许多个窃贼在不同的城市旅行，目的是最大化他们的总利润。旅行窃贼问题是一个具有挑战性的组合优化问题，近年来受到了广泛的关注。本文还提出了一些快速启发式算法来求解新提出的多旅行窃贼问题，并进行了评估。

Keywords: Fast heuristics => (multiple traveling thieves problem, MTTP)

### Q: 这篇文章发表会议/期刊属于CCF哪类？这篇文章在google scholar引用次数多少？

发表在2016年的GECCO会议上。GECCO是遗传和进化计算领域的国际会议，根据CCF排名³，它属于C类会议。根据谷歌学术⁸，这篇文章在2023年5月1日时被引用了23次。

### Q: GECCO是什么会议？

GECCO是**遗传和进化计算会议**的缩写，它是遗传和进化计算领域最大的同行评审会议，也是ACM遗传和进化计算特别兴趣小组(SIGEVO)的主要会议¹。GECCO涵盖了遗传算法、遗传编程、蚁群优化和群智能、复杂系统、进化组合优化和元启发式、进化机器学习、进化多目标优化、进化数值优化等多个主题²。GECCO每年举办一次，2023年将在葡萄牙里斯本举行³。

### Q: Introduce authors of this article in Chinese one by one

这篇文章的作者有两位，分别是：

- **Shelvin Chand**，他出生于斐济的劳托卡，分别于2013年和2014年在南太平洋大学获得了计算机科学和信息系统的学士学位和计算机科学的硕士学位。2018年，他在澳大利亚新南威尔士大学堪培拉分校获得了计算机科学的博士学位。目前，他是澳大利亚联邦科学与工业研究组织（CSIRO）机器人与自主系统组的博士后研究员。他的研究兴趣包括进化机器人和计算创造力¹²。
- **Markus Wagner**，他是阿德莱德大学计算机科学学院的高级讲师。他的研究兴趣包括进化计算、优化、搜索、元启发式、超启发式、进化机器人、进化艺术和创造力。他曾担任过多个国际会议和期刊的程序委员会成员、主席或编辑³。

## 1. INTRODUCTION

(Prompt: Generalize Section "INTRODUCTION" of this article in Chinese)

这篇文章介绍了一种新的组合优化问题，叫做多旅行窃贼问题（MTTP），它是旅行窃贼问题（TTP）的一个变体。TTP是一个将旅行商问题（TSP）和背包问题（KP）结合起来的挑战性问题，其中一个窃贼需要在访问所有城市的同时，选择一些有价值的物品带走。MTTP放宽了TTP的两个假设：只有一个窃贼和必须访问所有城市。MTTP允许多个窃贼参与，且不一定要访问每个城市，从而使问题更接近真实场景。作者讨论了MTTP的定义和特点，并提出了一些启发式算法来求解这个新问题。作者还利用现有的TTP实例来评估算法的性能，并分析了不同因素对结果的影响。

## 2. TRAVELING THIEF PROBLEM

(Prompt: Generalize Section "TRAVELING THIEF PROBLEM" of this article in Chinese)

旅行窃贼问题（TTP）是一个将两个著名的组合优化问题相互联系起来的挑战性问题，即旅行商问题（TSP）和0-1背包问题（KP）。TTP中，一个窃贼需要在访问所有城市的同时，选择一些有价值的物品带走。TTP的动机是为了系统地研究两个难题之间的相互作用，从而获得对解决实际问题更有效的方法的洞察。自从TTP被提出以来，已经有许多算法被提出来求解这个新颖的问题，它将两个相互依赖的子问题结合起来。本文对TTP进行了理论和实验方面的研究，并提出了一些精确求解方法。

## 3. PROPOSING A NEW VARIANT OF THE TRAVELING THIEF PROBLEM

本文提出了旅行窃贼问题的一个变体，这是最近提出的一个具有挑战性的组合优化问题。这个变体的动机是，TTP的定义中有两个假设：窃贼的数量被限制为一个，而且必须访问所有城市。通过移除这些约束，问题变得更接近现实场景。在核心上，MTTP仍然是两个著名的组合优化问题的简单组合。

MTTP由多个窃贼组成，他们可以访问一系列城市，每个城市都有一些有价值的物品，他们的目标是共同最大化他们的利润。问题的形式化在本文中详细讨论，并提出了一些启发式方法来解决新提出的MTTP。与此同时，还提出了一些问题特定的算子，这些算子也可能对未来在原始TTP领域的研究有用。

MTTP的形式化是这样的，可以重用现有的TTP实例来作为算法性能的基准。本文中呈现的所有代码和结果也可以在线获取，以鼓励在这个领域进行进一步的研究。

## 4. MTTP LOCAL SEARCH ROUTINES

(Prompt: Generalize Section "MTTP LOCAL SEARCH ROUTINES" of this article in Chinese)

According to Google Translate, the section "MTTP LOCAL SEARCH ROUTINES" of this article can be generalized in Chinese as follows:

MTTP局部搜索算法

在本节中，我们介绍了一些用于构造装载方案和旅行路线的局部搜索算法。

### 4.1 解决方案表示

MTTP的单个解决方案可以包含多个旅行路线和装载方案。我们使用以下表示方法来表示解决方案。为了保持一致，所有的旅行路线向量都是相同的大小，所有的装载方案向量也是相同的大小。对于单个窃贼，如果窃贼访问这些城市，则城市ID（向量中的城市标识符）表示为正值，如果窃贼不访问特定城市，则表示为负值。类似地，对于装载方案，如果窃贼从某个城市拿走了一个物品，则用1表示，如果没有拿走任何物品或者窃贼没有访问那个城市，则用0表示。

### 4.2 初始化

由于这是一个新问题，我们有必要尝试一系列不同的初始化方法。我们实现了四种不同的初始化方法。旅行路线的初始化是基于使用链式Lin-Kernighan启发式（CLK）[1]生成的最优或近似最优（就总距离而言）旅行路线。1

以下四种方法涵盖了不同的场景，让我们能够发现一个好的起点：

• Init1：将完整的CLK旅行路线分配给单个窃贼。剩余窃贼的初始旅行路线不涉及任何旅行。所有窃贼都以空装载方案开始。这相当于从TTP解决方案开始。

• Init2：遍历CLK旅行路线，随机地将每个城市分配给一个窃贼。每个城市只被一个窃贼访问，所有窃贼都以空装载方案开始。

• Init3：遍历CLK旅行路线，随机地将每个城市分配给一个窃贼。如果一个城市有多于一个物品，那么可以有多个窃贼访问该城市。所有窃贼都以空装载方案开始。

• Init4：每个窃贼被分配了CLK旅行路线的一部分。假设有n个窃贼，每部分的大小为（totalCities/n）。每个城市只被一个窃贼访问。然后使用PackIterative [6]对各自的旅行路线进行迭代贪心装载。PackIterative根据提供的旅行路线考虑物品的利润和重量以及它们到最终城市的距离。

### 4.3 删除城市算子

删除城市算子是一种简单直观的方法。窃贼的目标是最大化总利润，所以他们不仅要访问高利润的城市，还要避免低利润的城市。有些城市可能不值得访问，因为它们包含的物品价值低，或者到达它们的距离太远，花费不划算。

我们提出的减少距离的算子接受一个解决方案和一个城市ID作为输入。它检查这个城市是否被某个窃贼访问。如果是，就把这个城市从窃贼的旅行路线中移除，并把从这个城市拿走的物品从窃贼的装载方案中清除。

这个算子可以反复使用，以移除那些不产生期望收益的城市。

According to Google Translate, Section 4.4 of this article can be generalized in Chinese as follows:

### 4.4 跨窃贼变异

跨窃贼变异是用于在窃贼之间转移旅行路线和装载方案信息的算子。它以一个城市ID为输入，然后确定哪个窃贼（如果有的话）正在访问该城市。如果有多个窃贼访问该城市，就选择第一个窃贼。这个窃贼被称为旧窃贼。下一步是随机选择一个新窃贼，它可能已经访问过该城市，也可能没有。然后，旧窃贼的装载方案中对应该城市的部分被转移到新窃贼的装载方案中。转移信息后，相应的城市就从旧窃贼的旅行路线中移除。这也意味着新窃贼现在正在访问那个城市。

这可以帮助同时优化多个窃贼的旅行路线和装载方案。它也可以用作原始TTP公式中的交叉算子。

### 4.5 其他路线

在我们的研究中，我们还包括了文献中已有的一些算子。将这些方法修改为适用于MTTP很简单，我们只需要添加一个简单的检查，以确保只修改了活跃的项目和旅行路线元素，即那些对应于窃贼正在访问的位置的元素，而其他未访问的位置则保持不变。

4.5.1 位翻转

位翻转算子最初由[6]提出。该算子遍历给定的装载方案，并顺序地翻转装载位。如果看到适应度的改善，就保留更改，否则就忽略。然后对下一个位重复这个过程。简而言之，位翻转算子在给定特定旅行路线的情况下优化装载方案。

4.5.2 插入

插入算子[6]用于根据给定的装载方案修改和优化旅行路线。该算子通过从旅行路线中的一个位置移除一个城市，并将其插入到另一个位置来工作。可能有些有价值的物品是在旅行路线的开始部分被拾取的，这是由于城市在路线中的顺序。因此，插入算子试图通过重新排列旅行路线来延迟拾取这些物品，使得这些物品被拾取到末尾，以便对旅行路线前面部分的窃贼速度影响最小。

一个好的TTP解决方案可以通过在旅行路线开始时装载较少或较轻的物品，而在旅行路线结束时装载较高价值的物品来表征。插入算子试图实现这一点。

4.5.3 1+1 EA

(1+1)-EA是由Polyakovskiy等人[14]提出的一种简单的爬山法。与位翻转算子类似，(1+1)-EA也试图在给定特定旅行路线的情况下优化装载方案。它遍历装载方案，并以1/q的概率独立地反转每个项目。然后评估更新后的解决方案，看是否改善了适应度。如果看到改善，则保留更改，否则忽略。上述步骤重复多次以改善适应度。

## 5. LOCAL SEARCH ALGORITHMS

(Prompt: Generalize Section "LOCAL SEARCH ALGORITHMS" of this article in Chinese)

## 6. CONCLUDING REMARKS

(Prompt: Generalize Section "CONCLUDING REMARKS" of this article in Chinese)